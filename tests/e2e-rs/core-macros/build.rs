// Copyright (c) 2025 woxQAQ
//
// Licensed under the MIT License or Apache License 2.0
// See LICENSE files for details

//! Build script for E2E test macros
//!
//! This build script discovers test directory structure at compile time,
//! enabling dynamic YAML test file discovery without manual configuration.

use std::env;
use std::fs;
use std::path::Path;

fn main() {
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    // The tests directory is one level up from core-macros crate
    let tests_dir = Path::new(&manifest_dir).parent().unwrap().join("tests");

    // Discover all engine directories (mysql-5.7, mysql-8.0, postgresql-12, etc.)
    let engines = discover_engines(&tests_dir);

    // For each engine, discover test type directories (completion, hover, diagnostics)
    let discovery: Vec<(String, Vec<String>)> = engines
        .iter()
        .map(|engine| {
            let test_types = discover_test_types(&tests_dir.join(engine));
            (engine.clone(), test_types)
        })
        .collect();

    // Generate test_discovery.rs with directory structure
    let generated_code = generate_discovery_code(&discovery);
    let output_path = tests_dir.join("test_discovery.rs");

    fs::write(&output_path, generated_code).expect("Failed to write test_discovery.rs");

    // Tell cargo to track the tests directory for changes
    println!("cargo:rerun-if-changed=tests/");

    // Optional: Print debug info in development builds
    if env::var("DEBUG").is_ok() {
        println!("cargo:warning=Discovered {} engines", engines.len());
        for (engine, test_types) in &discovery {
            println!("cargo:warning=  {}: {:?}", engine, test_types);
        }
    }
}

/// Discover all engine directories under tests/
fn discover_engines(tests_dir: &Path) -> Vec<String> {
    fs::read_dir(tests_dir)
        .unwrap_or_else(|e| panic!("Failed to read tests directory {:?}: {}", tests_dir, e))
        .filter_map(|entry| entry.ok())
        .filter(|entry| entry.path().is_dir())
        .map(|entry| entry.file_name().to_string_lossy().to_string())
        .collect()
}

/// Discover all test type directories under an engine directory
fn discover_test_types(engine_dir: &Path) -> Vec<String> {
    fs::read_dir(engine_dir)
        .unwrap_or_else(|e| panic!("Failed to read engine directory {:?}: {}", engine_dir, e))
        .filter_map(|entry| entry.ok())
        .filter(|entry| entry.path().is_dir())
        .map(|entry| entry.file_name().to_string_lossy().to_string())
        .collect()
}

/// Generate Rust code with discovery results
fn generate_discovery_code(discovery: &[(String, Vec<String>)]) -> String {
    let mut code = String::from("// Auto-generated by build.rs\n");
    code.push_str("// DO NOT EDIT\n\n");
    code.push_str("//! Test discovery data generated by build script\n");
    code.push_str("//! Contains mappings of engine -> test_types for dynamic test discovery\n\n");

    for (engine, test_types) in discovery {
        let const_name = to_const_name(engine);
        let test_types_array = format!(
            "&[{}]",
            test_types
                .iter()
                .map(|t| format!("\"{}\"", t))
                .collect::<Vec<_>>()
                .join(", ")
        );
        code.push_str(&format!(
            "pub const {}: &[&str] = {};\n",
            const_name, test_types_array
        ));
    }

    code
}

/// Convert engine name to const name (e.g., "mysql-5.7" -> "MYSQL_5_7")
fn to_const_name(engine: &str) -> String {
    engine.replace("-", "_").replace(".", "_").to_uppercase()
}
