# SQL LSP Playground Design

**Date:** 2026-01-18
**Status:** Draft
**Author:** Claude (Brainstorming Session)

## Problem Statement

Developers evaluating the Unified SQL LSP need an interactive way to test and validate the LSP's capabilities before integrating it into their IDE/editor. Currently, there is no easy way to demonstrate completions, hover tooltips, and diagnostics in a live environment.

## Proposed Solution

Build a web-based playground that runs the LSP server in WebAssembly, allowing developers to write SQL queries and see real-time completions, hover information, and syntax/semantic diagnostics directly in their browser.

## Target Audience

**Primary:** Developers evaluating whether to integrate this LSP into their IDE/editor
**Secondary:** Contributors to the project who need a quick test environment

## Architecture

### High-Level Approach

**Chosen Approach: Monaco Editor + WASM LSP**

We'll use Monaco Editor (VS Code's editor component) as the frontend and compile the Rust LSP server to WebAssembly. This provides the most authentic evaluation experience since developers can write real SQL queries and see how the LSP responds.

**Alternatives Considered:**
- CodeMirror + Mocked Responses: Simpler but not authentic LSP behavior
- Pure WebDemo with Pre-recorded Scenarios: Limited flexibility, doesn't show real capabilities

### Component Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                      Frontend UI Layer                          │
│  - Monaco Editor (SQL syntax highlighting)                     │
│  - Schema Browser (tables, columns)                            │
│  - Diagnostics Panel (errors, warnings)                        │
│  - Settings (dialect selector, theme toggle)                   │
├─────────────────────────────────────────────────────────────────┤
│                      LSP Bridge Layer                           │
│  - Protocol Adapter (Monaco ↔ LSP)                             │
│  - WASM Interface (JS ↔ WASM communication)                    │
│  - Message Queue (async handling)                              │
│  - State Management (document versions, diagnostics)           │
├─────────────────────────────────────────────────────────────────┤
│                      WASM LSP Server                            │
│  - Modified LspBackend (stdio-free)                            │
│  - Memory Management (WASM heap)                               │
│  - Export Interface (completion, hover, diagnostics)           │
│  - Static Catalog (sample schemas)                             │
└─────────────────────────────────────────────────────────────────┘
```

### Data Flow

```
User types in Monaco
  → Protocol Adapter creates LSP message
  → wasm-bindgen calls into WASM
  → Rust LSP processes request
  → Returns result via wasm-bindgen
  → Adapter converts to Monaco format
  → UI displays completion/hover/diagnostic
```

## File Structure

```
crates/
  lsp/
    src/
      bin/main.rs              # Existing stdio LSP server
      backend.rs               # Existing tower-lsp backend
      core.rs                  # NEW: Shared LSP logic
      wasm/
        mod.rs                 # NEW: WASM-specific backend
        exports.rs             # NEW: wasm-bindgen exports
        lib.rs                 # NEW: Module exports
    Cargo.toml                 # Add wasm32 dependencies

playground/
  src/
    components/
      Editor.tsx               # Monaco wrapper
      SchemaBrowser.tsx        # Table/column tree view
      DiagnosticsPanel.tsx     # Error/warning list
      StatusBar.tsx            # Dialect, position, status
    lib/
      lsp-bridge.ts            # LSP protocol adapter
      wasm-interface.ts        # WASM module loader
    main.tsx                   # App entry point
  src/wasm/                    # Generated by wasm-pack
    unified_sql_lsp_lsp.js
    unified_sql_lsp_lsp_bg.wasm
  index.html
  package.json
  vite.config.ts
  tsconfig.json
```

## UI Layout

```
┌─────────────────────────────────────────────────────────┐
│  Header: Unified SQL LSP Playground  [Dialect: MySQL ▼] │
├──────────────┬──────────────────────────────────────────┤
│              │                                          │
│  Schema      │      Monaco Editor Area                  │
│  Browser     │      (main SQL input)                    │
│              │                                          │
│  ┌─users─┐   │  SELECT * FROM users WHERE...            │
│  │ id    │   │                                          │
│  │ name  │   │  ┌─────────────────────────────────┐    │
│  │ email │   │  │ Hover popup / Completion menu  │    │
│  └───────┘   │  └─────────────────────────────────┘    │
│              │                                          │
│  ┌─orders─┐  │                                          │
│  │ ...   │   │                                          │
│  └───────┘   │                                          │
├──────────────┴──────────────────────────────────────────┤
│  Diagnostics Panel (0 errors, 2 warnings)               │
│  ⚠ Line 3: Column 'invalid_col' does not exist          │
└─────────────────────────────────────────────────────────┘
```

## Features

### Core LSP Features

1. **Completions** (Essential)
   - Tables, columns, keywords, functions
   - Context-aware (SELECT clause vs FROM clause)
   - Triggered automatically or via Ctrl+Space

2. **Hover Tooltips** (Important)
   - Column types
   - Function signatures
   - Table information

3. **Diagnostics** (Important)
   - Syntax errors
   - Undefined tables/columns
   - Type mismatches
   - Inline squiggles + panel view

### UX Features

4. **Dialect Switcher**
   - Dropdown: MySQL, PostgreSQL, TiDB
   - Resets editor and diagnostics on change
   - Visual indicator of active dialect

5. **Schema Browser**
   - Tree view: Database → Tables → Columns
   - Click column to insert at cursor
   - Shows column types

6. **Example Queries**
   - Preloaded query dropdown
   - "Show me completions" tutorial mode
   - Demonstrates different features

## Sample Schema

```sql
-- MySQL demo schema
CREATE TABLE users (
  id INT PRIMARY KEY,
  name VARCHAR(100),
  email VARCHAR(255),
  created_at TIMESTAMP
);

CREATE TABLE orders (
  id INT PRIMARY KEY,
  user_id INT,
  total DECIMAL(10,2),
  status ENUM('pending','complete'),
  FOREIGN KEY (user_id) REFERENCES users(id)
);

CREATE TABLE order_items (
  id INT PRIMARY KEY,
  order_id INT,
  product_id INT,
  quantity INT,
  FOREIGN KEY (order_id) REFERENCES orders(id)
);
```

## WASM Implementation

### Challenge

The current LSP backend uses `tower-lsp` and expects stdio transport, which won't work in WASM.

### Solution: Shared Core + Multiple Backends

1. **Extract Shared Core**
   - Move LSP business logic from `backend.rs` to `core.rs`
   - Both tower-lsp and WASM backends use the same core
   - Single source of truth for LSP behavior

2. **WASM Exports**

```rust
// crates/lsp/src/wasm/exports.rs
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub struct LspServer {
    backend: LspCore,
}

#[wasm_bindgen]
impl LspServer {
    #[wasm_bindgen(constructor)]
    pub fn new(dialect: &str) -> Self {
        // Initialize with static catalog
    }

    pub fn completion(&self, text: &str, line: u32, col: u32) -> JsValue {
        // Return JSON completion items
    }

    pub fn hover(&self, text: &str, line: u32, col: u32) -> JsValue {
        // Return hover info
    }

    pub fn diagnostics(&self, text: &str) -> JsValue {
        // Return diagnostic array
    }
}
```

3. **Build Configuration**
   - Add `wasm32-unknown-unknown` target
   - Conditional compilation: `#[cfg(not(target_arch = "wasm32"))]`
   - Feature flag: `wasm` for WASM-specific dependencies
   - Use `wasm-pack` for building

## Error Handling

### WASM-Specific Challenges

1. **Memory Management**
   - Add memory usage indicator in UI
   - Graceful degradation when approaching limits
   - Warning at 80% heap usage
   - Fallback: Reload message when limit exceeded

2. **Async Operations**
   - Use `wasm-bindgen-futures` for async bridge
   - Show loading indicator during operations
   - Debounce rapid keystrokes (300ms)

3. **Panic Handling**
   - Wrap all exports in `catch_unwind`
   - Return error object instead of crashing
   - Add "Reset Playground" button for recovery

### LSP Edge Cases

4. **Incomplete Queries**
   - Return empty completion list (not error)
   - Show "No completions available" toast

5. **Dialect Switching Mid-Query**
   - Warning modal: "Switching dialect will clear diagnostics. Continue?"
   - Option to copy query before switching

6. **Malformed SQL**
   - Show syntax error diagnostics
   - Still provide completions using heuristics
   - Don't block user input

## Technology Stack

- **Frontend Framework**: React 18 with TypeScript
- **Editor**: Monaco Editor (VS Code's editor)
- **Build Tool**: Vite (dev server + bundler)
- **WASM Tooling**: wasm-bindgen, wasm-pack
- **UI Library**: shadcn/ui (optional, for polish)
- **Deployment**: GitHub Pages or Netlify

## Implementation Roadmap

### Phase 1: Foundation (1-2 days)
- Set up playground project structure
- Configure Vite + TypeScript + React
- Add Monaco Editor dependency
- Create basic three-panel layout
- Static schema browser with hardcoded schema
- **Milestone**: Blank editor with schema panel

### Phase 2: WASM Infrastructure (2-3 days)
- Add `wasm32-unknown-unknown` target to workspace
- Extract shared LSP logic from `backend.rs` to `core.rs`
- Create `lsp/src/wasm/` module
- Set up `wasm-bindgen` exports
- Implement basic `completion` export
- Configure `wasm-pack` build
- **Milestone**: Hello World WASM module callable from JS

### Phase 3: LSP Bridge Layer (2 days)
- Implement `LspBridge` class in TypeScript
- Wire up Monaco → WASM for completion
- Add document version tracking
- Implement debounce logic
- Handle async responses
- **Milestone**: Completions appear when typing

### Phase 4: Feature Integration (2-3 days)
- Add `hover` export and bridge
- Add `diagnostics` export and bridge
- Implement diagnostic panel UI
- Add squiggles in Monaco editor
- Wire up schema browser clicks
- Add dialect switcher
- **Milestone**: All three features working end-to-end

### Phase 5: Polish (1-2 days)
- Add example queries dropdown
- Implement "Quick Start" tutorial
- Add loading states
- Performance optimization
- Error handling improvements
- Responsive design tweaks
- **Milestone**: Production-ready playground

### Phase 6: Deployment (1 day)
- Set up GitHub Pages or Netlify
- Configure CI/CD for automatic builds
- Add build script to Makefile
- Test on multiple browsers
- **Milestone**: Publicly accessible URL

**Total Timeline**: 9-13 days

## Build Commands

Add to `Makefile`:

```makefile
## Playground
playground-build:
	cd playground && npm run build

playground-dev:
	cd playground && npm run dev

playground-wasm:
	wasm-pack build crates/lsp --target web --out-dir playground/src/wasm
```

## Performance Considerations

- **Bundle Size Target**: <5MB WASM module (gzipped)
- **Large File Handling**: Limit editor to ~5000 lines with warning
- **Incremental Diagnostics**: Don't re-analyze entire file on each keystroke
- **Code Splitting**: Load dialect grammars on-demand
- **Debouncing**: 300ms delay before sending LSP requests

## Browser Support

- Chrome/Edge 90+
- Firefox 88+
- Safari 14+
- Feature detection for WebAssembly support
- Fallback message for unsupported browsers

## Success Criteria

1. ✅ Developers can write SQL queries and see real-time completions
2. ✅ Hover tooltips show accurate type/signature information
3. ✅ Diagnostics correctly identify syntax and semantic errors
4. ✅ Dialect switching works seamlessly
5. ✅ Performance feels responsive (<300ms latency)
6. ✅ Works offline after initial load
7. ✅ Bundle size is reasonable (<5MB gzipped)

## Open Questions

None - approach is straightforward.

## Next Steps

After approval, proceed with implementation following the phased roadmap.
