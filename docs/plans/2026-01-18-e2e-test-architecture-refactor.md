# E2E Test Architecture Refactor Design

**Date:** 2026-01-18
**Author:** woxQAQ
**Status:** Proposed

## Problem Statement

The current E2E test architecture has three major limitations:

1. **Inefficient database lifecycle:** Each test case independently initializes and destroys database connections, causing significant overhead
2. **No parallelization across engines:** Tests must run serially even though MySQL 5.7, MySQL 8.0, PostgreSQL 12, and PostgreSQL 16 tests could run in parallel
3. **Poor code organization:** Test stubs are scattered in a flat `tests/` directory rather than organized by engine

## Proposed Solution

**Workspace-level engine isolation** - Split E2E tests into separate crates, one per database engine. Each engine crate:
- Has its own test binary and dependencies
- Initializes database once at crate level (not per test)
- Runs all tests serially within the engine
- Cleans up once after all tests complete

Different engine crates run in parallel via `cargo test --workspace`, achieving 3-4x speedup on multi-core machines.

## Architecture Overview

### Current Structure

```
tests/e2e-rs/
├── src/
│   ├── lib.rs              # All infrastructure in one place
│   ├── client.rs
│   ├── runner.rs
│   ├── assertions.rs
│   └── ...
├── tests/
│   ├── mysql_5_7_completion.rs     # ❌ Flat structure
│   ├── mysql_5_7_hover.rs
│   ├── mysql_8_0_completion.rs
│   ├── postgresql_12_completion.rs
│   └── ...
└── mysql-5.7/
    ├── completion/
    │   └── *.yaml     # YAML tests (unchanged)
    ├── hover/
    └── diagnostics/
```

**Problems:**
- Each test calls `init_database()` → starts ALL Docker containers
- Tests run serially due to shared database state
- Test stubs mixed together, unclear which engine they belong to

### New Structure

```
tests/e2e-rs/
├── Cargo.toml                    # Workspace root
├── docker-compose.yml            # Shared by all engines
│
├── core/                         # Shared library crate
│   ├── Cargo.toml
│   └── src/
│       ├── lib.rs
│       ├── client/
│       ├── runner/
│       ├── assertions/
│       ├── yaml_parser/
│       ├── db/
│       └── macros.rs             # Declarative test generation
│
├── mysql-5.7/                    # Engine crate
│   ├── Cargo.toml
│   └── tests/
│       └── integration_test.rs   # Auto-generated by macro
│
├── mysql-8.0/                    # Engine crate
├── postgresql-12/                # Engine crate
└── postgresql-16/                # Engine crate
```

**Benefits:**
- Database initialized once per engine crate
- Different engine crates run in parallel
- Clear organization by engine in filesystem

## Core Components

### 1. Shared Library Crate (`core/`)

Extracts all reusable testing infrastructure into a shared crate.

**Structure:**
```
core/src/
├── lib.rs              # Public API exports
├── runner.rs           # LspRunner (spawn LSP server)
├── client.rs           # LspConnection (protocol handling)
├── assertions.rs       # Test assertions
├── yaml_parser.rs      # YAML → TestSuite
├── db/
│   ├── adapter.rs      # DatabaseAdapter trait
│   ├── mysql.rs
│   └── postgresql.rs
└── macros.rs           # Declarative test generation
```

**Public API:**
```rust
use unified_sql_lsp_e2e_core::{
    run_test,              // Execute single test from YAML
    Engine,                // MySQL57, MySQL80, etc.
    ensure_engine_ready,   // RAII guard for database lifecycle
};

// Macro to generate test stubs from YAML files
generate_engine_tests!(
    engine: MySQL57,
    test_dir: "tests/mysql-5.7",
    test_types: [completion, hover, diagnostics]
);
```

### 2. Engine-Specific Crates

Each engine crate is minimal, consisting only of:

```toml
# mysql-5.7/Cargo.toml
[package]
name = "mysql-5-7-e2e-tests"

[dependencies]
unified-sql-lsp-e2e-core = { path = "../core" }
tokio = { workspace = true }
serial_test = "3.0"
```

```rust
// mysql-5.7/tests/integration_test.rs
use unified_sql_lsp_e2e_core::{generate_engine_tests, Engine};

generate_engine_tests!(
    engine: MySQL57,
    test_dir: "tests/mysql-5.7",
    test_types: [completion, hover, diagnostics]
);
```

The macro expands to individual `#[tokio::test]` functions, one per YAML file.

## Test Execution Flow

### Lifecycle Management

Database lifecycle happens **once per engine cargo test invocation**, not per individual test:

```
┌─────────────────────────────────────────────────────────────┐
│ cargo test --package mysql-5-7-e2e-tests                    │
├─────────────────────────────────────────────────────────────┤
│ 1. Load test YAML files (discovery phase)                   │
│ 2. Start Docker Compose (all containers once)               │
│ 3. Initialize MySQL 5.7 database adapter                    │
│    - Cleanup old database                                   │
│    - Create fresh schema                                    │
│ 4. Run all tests serially:                                  │
│    test_completion_from_clause  ◄──┐                        │
│    test_completion_join           │  Reuse same             │
│    test_hover_basic               │  database               │
│    test_diagnostics_error      ───┘  connection             │
│ 5. Drop guard → cleanup database                           │
└─────────────────────────────────────────────────────────────┘
```

### Parallel Execution

Different engine crates run as separate `cargo test` processes in parallel:

```
│ Parallel execution (different cargo test processes):
├─ mysql-5-7-e2e-tests  (process 1) ──┐
├─ mysql-8-0-e2e-tests  (process 2)   ├──► 4x speedup
├─ postgresql-12-tests (process 3)   │    (4-core machine)
└─ postgresql-16-tests (process 4) ───┘
```

### Test Discovery

The macro walks `test_dir/{test_types}/*.yaml` at **compile time** to generate test functions:

```rust
// Input:
generate_engine_tests!(
    engine: MySQL57,
    test_dir: "tests/mysql-5.7",
    test_types: [completion, hover, diagnostics]
);

// Output (conceptual):
#[cfg(test)]
mod tests {
    #[tokio::test]
    #[serial(mysql_57)]
    async fn test_completion_from_clause() -> anyhow::Result<()> {
        static INIT: OnceLock<()> = OnceLock::new();
        INIT.get_or_init(|| {
            // One-time init: start Docker, create database
        });

        let _guard = ensure_engine_ready(&Engine::MySQL57).await?;
        run_test("tests/mysql-5.7/completion/from_clause.yaml").await
    }

    // ... more generated tests
}
```

## Workspace Configuration

### Root Cargo.toml

```toml
[workspace]
resolver = "2"
members = ["core", "mysql-5.7", "mysql-8.0", "postgresql-12", "postgresql-16"]

[workspace.dependencies]
tokio = { version = "1.40", features = ["full", "rt-multi-thread"] }
anyhow = "1.0"
serial_test = "3.0"
tower-lsp = "0.20"
```

### Running Tests

```bash
# Run all engines in parallel
cargo test --workspace --jobs 4

# Run specific engine
cargo test --package mysql-5-7-e2e-tests

# Run with custom parallelism
cargo test --workspace --jobs 8
```

### Makefile Integration

```makefile
test-e2e:
	cargo test --workspace --jobs 4

test-e2e-mysql-5.7:
	cargo test --package mysql-5-7-e2e-tests
```

## File Organization

### YAML Test Files (No Change!)

**Key point:** YAML test definitions stay where they are, no migration needed:

```
tests/e2e-rs/
├── mysql-5.7/
│   ├── completion/
│   │   ├── from_clause.yaml     # Unchanged
│   │   ├── join.yaml            # Unchanged
│   │   └── ...
│   ├── hover/
│   └── diagnostics/
├── mysql-8.0/
│   └── completion/
└── postgresql-12/
    └── completion/
```

The macro in each engine's `integration_test.rs` simply points to the existing YAML directories.

### Test Stub Removal

**Old structure** (files to delete):
```
tests/e2e-rs/tests/
├── mysql_5_7_completion.rs   ❌ DELETE
├── mysql_5_7_hover.rs        ❌ DELETE
├── mysql_8_0_completion.rs   ❌ DELETE
├── postgresql_12_completion.rs ❌ DELETE
└── diagnostics.rs            ❌ DELETE
```

**New structure:** One generated file per engine
```
tests/e2e-rs/mysql-5.7/tests/integration_test.rs  ✅ Generated by macro
```

## Macro Implementation

### Declarative Test Generation

**`core/src/macros.rs`:**

```rust
#[proc_macro]
pub fn generate_engine_tests(input: TokenStream) -> TokenStream {
    // Parse input: engine, test_dir, test_types
    let args = parse_macro_input!(input as EngineTestArgs);

    // Discover YAML files at compile time
    let yaml_files = discover_yaml_files(&args.test_dir, &args.test_types);

    // Generate test functions
    let tests = yaml_files.iter().map(|yaml| {
        let test_name = yaml_to_test_name(yaml);
        let test_path = yaml.path();
        let serial_key = args.engine.serial_key();

        quote! {
            #[tokio::test]
            #[serial(#serial_key)]
            async fn #test_name() -> anyhow::Result<()> {
                let _guard = ensure_engine_ready(&Engine::#engine_ident).await?;
                run_test(#test_path).await
            }
        }
    });

    // Wrap in module
    quote! {
        mod #engine_ident_lower {
            use super::*;
            #(#tests)*
        }
    }
}
```

### Compile-time YAML Discovery

```rust
fn discover_yaml_files(base_dir: &str, types: &[&str]) -> Vec<PathBuf> {
    types.iter()
        .flat_map(|t| {
            glob(&format!("{base_dir}/{t}/**/*.yaml"))
                .unwrap()
                .filter_map(Result::ok)
        })
        .collect()
}
```

This ensures test discovery happens at **compile time** - missing YAML files cause compilation errors, not silent test skips.

## Migration Strategy

### Phase 1: Prepare Foundation (Non-Breaking)

1. Create new structure alongside existing code
2. Move shared code to `core/`
3. Create workspace `Cargo.toml` keeping old tests working

**Verification:** Existing `cargo test` still works unchanged.

### Phase 2: Implement Engine Crates

4. Create first engine crate (MySQL 5.7)
5. Validate parallel execution
6. Repeat for other engines

### Phase 3: Migrate Tests & Remove Old Code

7. Update CI/CD and Makefile
8. Delete old test stubs
9. Clean up old `src/` (now in `core/src/`)

### Phase 4: Validation

10. **Performance validation:**
    - Measure baseline: Current test runtime
    - Measure new runtime: Should be ~3-4x faster
    - Verify database init/cleanup happens once per engine

11. **Correctness validation:**
    - All YAML tests produce identical results
    - No test regressions
    - Proper error handling

**Rollback plan:** Keep old tests directory renamed as `tests_old/` until migration is verified.

## Expected Benefits

1. **3-4x speedup:** Engines run in parallel on multi-core machines
2. **Reduced overhead:** Database init/cleanup happens once per engine, not per test
3. **Better organization:** Clear separation by engine in filesystem
4. **Declarative tests:** YAML drives everything via macros
5. **Compile-time safety:** Missing test files caught at compilation

## Risks & Mitigations

| Risk | Mitigation |
|------|------------|
| Increased build complexity | Workspace structure is standard Rust pattern |
| Macro maintenance cost | Macro is simple and well-tested |
| Docker resource contention | Limit parallelism via `--jobs` flag |
| Migration breaking existing tests | Phased migration with rollback plan |

## Next Steps

1. Review and approve this design
2. Implement Phase 1 (foundation)
3. Implement Phase 2 (engine crates)
4. Validate performance improvements
5. Complete migration and remove old code
