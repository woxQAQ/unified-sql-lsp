# 统一 SQL LSP 服务器 - 技术设计文档

## 1. 项目概述

### 1.1 目标
设计和实现一个统一的语言服务器协议（LSP）服务器，为多种数据库引擎提供智能 SQL 代码补全。系统必须支持几十种不同的 SQL 数据库，具有高可扩展性，同时保持实时性能。

### 1.2 核心目标
- 支持多种 SQL 数据库引擎（称为"引擎"）
- 处理引擎特定的语法差异和版本差异
- 提供上下文感知的代码补全
- 根据用户上下文过滤 schema 建议
- 并发服务多个连接
- 保持生产级性能

### 1.3 范围
**包含：**
- LSP 补全接口实现
- 多引擎架构与 Add-on 系统
- 上下文感知补全
- Schema 管理和过滤
- 多连接处理

**不包含：**
- 跳转定义（go to definition）
- 查找引用（find references）
- 代码检查/诊断
- 格式化
- 重构

---

## 2. 架构设计

### 2.1 高层架构

系统采用**分层架构与 WebAssembly 插件系统**：

```
┌─────────────────────────────────────┐
│          多个 Web 客户端            │
│   (浏览器标签页、不同用户会话)       │
└─────────────────┬───────────────────┘
                  │
                        │ LSP 协议
                 ┌──────▼──────┐
                 │ LSP 传输层  │
                 │ (stdio/TCP) │
                 └──────┬──────┘
                        │
                 ┌──────▼──────┐
                 │ 请求分发器  │
                 └──────┬──────┘
                        │
        ┌───────────────┴───────────────┐
        │                               │
┌───────▼───────┐              ┌────────▼────────┐
│ 连接管理器    │              │  Add-on 管理器  │
│ - 多客户端    │              │  - Wasm 运行时  │
│ - 单连接/客户 │              │  - 引擎 Add-ons │
└───────┬───────┘              └────────┬────────┘
        │                               │
        └───────────┬───────────────────┘
                    │
         ┌──────────┴──────────┐
         │                     │
    ┌────▼────┐          ┌─────▼─────┐
    │ 补全引擎 │          │ Wasm 模块 │
    │         │          │   池      │
    └────┬────┘          └─────┬─────┘
         │                     │
         └──────────┬──────────┘
                    │
         ┌──────────┴──────────┐
         │                     │
    ┌────▼────┐          ┌─────▼─────┐
    │ PG Wasm │          │ MySQL Wasm│
    │ Add-on  │          │ Add-on    │
    └─────────┘          └───────────┘
```

**架构特点：**
- **多客户端单连接模型**：每个 LSP 客户端（如 Web 端、VS Code）维护一个数据库连接
- **集中式服务器**：单个 LSP 服务器实例同时服务多个客户端
- **Wasm 插件隔离**：每个引擎 Add-on 编译为独立的 Wasm 模块
- **增量解析**：基于 Tree-sitter 的高性能增量解析

### 2.2 核心组件

#### 2.2.1 LSP 传输层
**职责：**
- 处理 LSP 协议通信（JSON-RPC）
- 管理客户端连接
- 协议版本协商

**关键考虑：**
- 同时支持 stdio 和 TCP 传输
- 优雅处理断开连接
- 请求/响应关联

#### 2.2.2 请求分发器
**职责：**
- 将传入请求路由到适当的处理器
- 管理请求生命周期
- 光标移动时取消过期请求

**关键考虑：**
- 请求取消对性能至关重要
- 对快速补全请求进行防抖
- 为每个连接维护请求上下文

#### 2.2.3 连接管理器
**职责：**
- 维护多个活动的数据库连接
- 连接池
- 健康检查和重连
- 身份验证管理

**关键考虑：**
- 每个 LSP 客户端维护一个数据库连接（多客户端单连接模型）
- 连接标识使用安全设计，不包含敏感信息
- 支持连接池和健康检查
- 优雅处理连接失败和重连

#### 2.2.4 Add-on 管理器
**职责：**
- 发现和加载 Wasm 引擎 Add-on
- 管理 Wasm 运行时和模块实例
- 将请求路由到适当的 Add-on
- 处理版本特定行为
- 管理 Wasm 模块的生命周期

**关键考虑：**
- Add-on 的动态加载/卸载（Wasm 模块）
- Wasm 运行时管理（使用 wazero）
- Add-on 隔离（Wasm 沙箱保证隔离性）
- 预编译和缓存 Wasm 模块
- 主机函数导出（schema 查询、日志等）

#### 2.2.5 补全引擎
**职责：**
- 解析 SQL 上下文
- 生成补全候选项
- 排序和过滤建议
- 应用上下文感知规则

**关键考虑：**
- 必须极快（典型补全 < 100ms）
- 支持增量解析（不要重新解析整个文档）
- 缓存中间结果

#### 2.2.6 Schema 缓存管理器
**职责：**
- 获取并缓存数据库 schema
- 监控 schema 变化
- 维护 schema 元数据
- 根据上下文过滤 schema

**关键考虑：**
- Schema 获取开销大，需积极缓存
- 支持增量 schema 更新
- 处理大型 schema（数千个对象）
- 尊重安全性/权限（仅显示可访问的对象）

---

## 3. Add-on 系统设计

### 3.1 Add-on 定义

**Add-on** 是一个自包含的模块，实现对特定数据库引擎的支持（如 PostgreSQL、MySQL、Oracle）。

### 3.2 Add-on 契约

每个 Add-on 必须实现以下接口：

#### 3.2.1 引擎元数据
```go
type EngineMetadata struct {
    EngineName      string
    SupportedVersions []string
    DefaultVersion  string
    SyntaxFlavor    string
}
```

#### 3.2.2 解析器接口

**决策：引擎特定解析器**

每个 Add-on 实现自己的解析器，针对特定的 SQL 方言进行优化，确保最大的准确性和性能。

**理由：**
- SQL 方言在语法上差异显著（例如，PostgreSQL 的 ARRAY 与 MySQL 的 JSON）
- 引擎特定解析器完美处理方言细节
- 为了统一性不妥协解析器准确性
- 每个 Add-on 可以使用最适合其引擎的解析方法（手写、解析器生成器等）

**解析器职责：**
- 解析 SQL 语句并提取上下文
- 识别语句类型（SELECT、INSERT 等）
- 提取光标位置上下文
- 返回解析树或上下文对象
- 处理引擎特定的语法变体

#### 3.2.3 补全提供者接口
- 生成关键字补全
- 生成函数补全
- 应用引擎特定规则
- 处理版本特定功能

#### 3.2.4 Schema 提供者接口
- 从数据库查询 schema
- 解析 schema 元数据
- 将数据库类型映射到通用类型
- 处理系统 schema 与用户 schema

### 3.3 Add-on 发现和加载

**决策：WebAssembly (Wasm) 插件系统**

Add-on 将编译为独立的 Wasm 模块，提供最大的灵活性、安全性和可扩展性。

**架构：**
- 每个 Add-on 编译为 Wasm 模块（.wasm 文件）
- 使用 wazero 运行时（纯 Go 实现，无需 CGo）
- Wasm 沙箱提供完全的隔离性
- 无网络通讯开销，直接函数调用

**实现方法（Go 1.24+）：**

**核心技术：**
- **Go 1.24+ `go:wasmexport` 指令**：导出 Go 函数到 Wasm
- **wazero 运行时**：纯 Go 实现的 Wasm 运行时，零依赖
- **主机函数导入**：Wasm 模块调用主机提供的函数（如 schema 查询）

**Wasm Add-on 结构：**
```
addons/postgresql/
├── manifest.yaml        # Add-on 元数据
├── parser.go            # 解析器实现（Go 1.24+）
├── completion.go        # 补全逻辑
├── grammar.js           # Tree-sitter 语法文件
├── postgresql.wasm      # 编译的 Wasm 模块
└── README.md            # 文档
```

**manifest.yaml 格式：**
```yaml
name: postgresql
version: 1.0.0
engine: PostgreSQL
supported_versions:
  - "10"
  - "11"
  - "12"
  - "13"
  - "14"
  - "15"
  - "16"
parser:
  type: tree-sitter
  grammar: grammar.js
wasm:
  file: postgresql.wasm
  size: 2048  # KB
capabilities:
  - completion
  - diagnostics
  - schema_introspection
author: Your Name
license: MIT
```

**Wasm 模块实现（Go 1.24+）：**
```go
package main

//go:wasmexport parse
func parse(ptr, length uint32) uint32 {
    // 解析 SQL 语句
    // 返回解析树的指针
}

//go:wasmexport complete
func complete(contextPtr, contextLen uint32) uint32 {
    // 生成补全建议
    // 返回结果数组的指针
}

//go:wasmexport metadata
func metadata() (ptr, length uint32) {
    // 返回 Add-on 元数据
}

// 导入主机函数
//go:wasmimport host getSchema
func getSchema(dbName string) (*SchemaInfo, error)

//go:wasmimport host logMessage
func logMessage(level, ptr, length uint32)
```

**Wasm Add-on 加载器：**
```go
type WasmAddonLoader struct {
    runtime *wazero.Runtime
    cache   map[string]*wazero.CompiledModule
    instances map[string]wazero.Module
}

func (l *WasmAddonLoader) Load(manifestPath string) (Addon, error) {
    // 1. 读取 manifest.yaml
    // 2. 预编译 Wasm 模块
    // 3. 实例化 Wasm 模块
    // 4. 导出函数绑定
    // 5. 返回 Addon 接口
}
```

**插件生命周期：**
1. **发现**：扫描配置目录中的 manifest.yaml 文件
2. **验证**：验证清单格式和 Wasm 模块兼容性
3. **编译**：预编译 Wasm 字节码（wazero 支持预编译）
4. **实例化**：创建 Wasm 模块实例
5. **注册**：向 Add-on 管理器注册
6. **运行**：通过导出的函数处理请求
7. **卸载**：优雅关闭和资源清理

**优势：**
- ✅ **安全性**：Wasm 沙箱完全隔离，一个 Add-on 崩溃不影响服务器
- ✅ **性能**：无网络通讯开销，直接函数调用
- ✅ **跨平台**：Wasm 模块可在任何平台运行
- ✅ **零依赖**：无需 CGo，wazero 是纯 Go 实现
- ✅ **热重载**：可以在运行时重新加载 Wasm 模块
- ✅ **开发效率**：使用 Go 1.24+ 的 `go:wasmexport`，开发体验极佳

### 3.4 版本处理

每个 Add-on 必须支持：
- 从数据库检测版本
- 版本特定功能标志
- 版本相关的补全规则
- 对未知版本的优雅降级

**实现策略：**
- 数据库版本的语义版本控制
- 每个版本的功能能力矩阵
- 版本未知时默认为最低公分母

**版本检测方法：**
- PostgreSQL: `SELECT version()` 或 `SELECT current_setting('server_version')`
- MySQL: `SELECT VERSION()` 或 `SHOW VARIABLES LIKE 'version'`

### 3.5 解析器生成策略

**核心要义：「得到语法解析器」**

设计的核心在于如何高效、方便地从官方语法文件生成解析器。

**推荐方案：官方语法文件 → Tree-sitter → Wasm**

#### 3.5.1 解析器生成流程

```
1. 获取官方语法文件
   PostgreSQL: src/backend/parser/gram.y
   MySQL:      sql/sql_yacc.yy

2. 转换为 Tree-sitter 语法
   - 编写 grammar.js（或使用转换工具）
   - 定义词法规则和语法规则
   - 测试语法正确性

3. 编译为 Tree-sitter 解析器
   - 使用 tree-sitter-cli 生成解析器
   - 编译为共享库或 Wasm 模块

4. 集成到 Add-on
   - 封装 Tree-sitter API
   - 实现增量解析
   - 编译为 Wasm 模块
```

#### 3.5.1.1 官方语法文件获取方式

**PostgreSQL**:
- 官方仓库：https://github.com/postgres/postgres
- 语法文件：`src/backend/parser/gram.y`
- 获取方式：
  ```bash
  # 克隆特定版本
  git clone --branch REL_14_STABLE https://github.com/postgres/postgres.git
  cp postgres/src/backend/parser/gram.y addons/postgresql/gram-original/

  # 或下载单个文件
  wget https://raw.githubusercontent.com/postgres/postgres/REL_14_STABLE/src/backend/parser/gram.y
  ```

**MySQL**:
- 官方仓库：https://github.com/mysql/mysql-server
- 语法文件：`sql/sql_yacc.yy`
- 获取方式：
  ```bash
  # 克隆特定版本
  git clone --branch mysql-8.0 https://github.com/mysql/mysql-server.git
  cp mysql-server/sql/sql_yacc.yy addons/mysql/yy-original/
  ```

#### 3.5.1.2 获取失败时的备选方案

**备选方案1：使用已发布的解析器库**
- PostgreSQL: 使用 `libpq` 的解析器接口
- MySQL: 使用现有的 SQL 解析库（如 `vitess-io/vitess`）

**备选方案2：手动编写 grammar.js**
- 参考官方文档和 SQL 标准
- 使用现有的 tree-sitter-sql 项目作为起点
- 逐步完善语法规则

**备选方案3：社区资源**
- 参考开源项目的 SQL 解析器实现
- 使用 SQL 标准文档（ISO/IEC 9075）

**实现策略**：
```go
// internal/parser/grammar_fetcher.go
type GrammarFile struct {
    Source    string // "official", "community", "manual"
    Version   string
    Path      string
    FetchedAt time.Time
}

func FetchGrammarFile(engine, version string) (*GrammarFile, error) {
    // 1. 尝试从官方仓库获取
    if gf, err := fetchFromOfficialRepo(engine, version); err == nil {
        return gf, nil
    }

    // 2. 尝试从本地缓存获取
    if gf, err := fetchFromCache(engine, version); err == nil {
        log.Warn("Using cached grammar file", "engine", engine, "version", version)
        return gf, nil
    }

    // 3. 使用社区版本
    if gf, err := fetchFromCommunity(engine, version); err == nil {
        log.Warn("Using community grammar file", "engine", engine, "version", version)
        return gf, nil
    }

    return nil, fmt.Errorf("failed to fetch grammar file for %s %s", engine, version)
}
```

#### 3.5.1.3 版本差异处理

**策略1：版本特性矩阵**
```yaml
# addons/postgresql/versions.yaml
supported_versions:
  - "10"
  - "11"
  - "12"
  - "13"
  - "14"
  - "15"
  - "16"

version_features:
  "14":
    - SQL standard schema
    - multiranges
  "15":
    - merge command
    - security invoker
```

**策略2：多版本 grammar 文件**
```
addons/postgresql/grammars/
├── common.js        # 所有版本共享
├── pg10.js          # PostgreSQL 10 特定
├── pg11.js          # PostgreSQL 11 特定
├── pg12.js
├── pg13.js
├── pg14.js
└── pg15+.js         # PostgreSQL 15+ 特定
```

**策略3：运行时版本检测**
```go
//go:wasmexport detectVersion
func detectVersion(ptr, length uint32) uint32 {
    // 1. 连接数据库
    // 2. 执行 SELECT version();
    // 3. 解析版本号
    // 4. 返回支持的特性列表
}
```

#### 3.5.1.4 语法文件更新机制

**自动化更新检查**：
```bash
# scripts/check-grammar-update.sh
./scripts/check-grammar-update.sh postgresql 14 15
# 对比两个版本的语法文件差异
# 生成变更报告
```

**版本差异对比工具**：
```bash
# 对比 PostgreSQL 14 和 15 的语法差异
git diff REL_14_STABLE REL_15_STABLE -- src/backend/parser/gram.y
```

**版本特定处理**：
- 使用最小公分母原则：支持最常用版本的语法
- 版本特定特性通过条件编译处理
- 提供版本兼容性文档

#### 3.5.2 为什么选择 Tree-sitter？

**优势：**
- ✅ **增量解析**：专为编辑器设计，仅重新解析修改的部分
- ✅ **错误恢复**：语法错误时仍能构建部分 AST
- ✅ **高性能**：解析速度极快，适合实时补全
- ✅ **多语言支持**：支持 Go、Rust、C 等多种绑定
- ✅ **社区支持**：已有 [tree-sitter-sql](https://github.com/DerekStride/tree-sitter-sql) 项目

**增量解析机制：**
Tree-sitter 会缓存解析树，当文档内容更新时，仅重新解析修改部分。这意味着用户在输入 SQL 语句时，补全请求可以复用之前的解析结果，极大提升响应速度。

#### 3.5.3 Tree-sitter 语法定义

**语法结构：**
Tree-sitter 使用 JavaScript 定义的 grammar.js 文件来描述 SQL 语法规则。每个规则对应一种 SQL 语句结构（SELECT、INSERT、UPDATE 等），支持递归定义和优先级控制。

**关键优势：**
- 增量解析：缓存解析树，仅更新变化部分
- 错误恢复：语法错误不会导致整个解析失败
- 可测试性：提供 corpus 测试机制验证语法正确性

#### 3.5.4 解析器生成工具

**工具链：**
```bash
# 1. 安装 tree-sitter-cli
npm install -g tree-sitter-cli

# 2. 生成解析器
tree-sitter generate

# 3. 编译为 Wasm
tree-sitter build --wasm

# 4. 测试解析器
tree-sitter test
```

**集成方案：**
可以将 tree-sitter 命令集成到 Makefile 或构建脚本中，实现自动化解析器生成和编译流程。

#### 3.5.5 从 Bison 到 Tree-sitter 的转换

**挑战：**PostgreSQL 和 MySQL 使用 Bison/Yacc 语法

**解决方案：**
1. **手动转换**：编写 grammar.js（推荐）
   - 完全控制语法定义
   - 针对补全场景优化

2. **自动化工具**： Bison → Tree-sitter 转换器
   - 作为开发工具提供
   - 加速语法转换过程

3. **混合方案**：
   - 关键语法手动编写
   - 非关键语法使用转换工具

### 3.6 引擎特定考虑

#### PostgreSQL Add-on
**独特功能：**
- 数组类型和运算符
- JSON/JSONB 运算符
- 表继承
- 自定义函数和扩展
- 搜索路径处理
- Schema 限定名称

**解析考虑：**
- 美元引用字符串 ($$...$)
- 数组构造函数语法 (ARRAY[...])
- 类型转换语法 (::)
- 窗口函数 (PARTITION BY, OVER)

**Schema 内省：**
- 查询：`information_schema.tables`、`information_schema.columns`
- 系统目录：`pg_class`、`pg_attribute`、`pg_namespace`
- 尊重 `search_path` 进行名称解析
- 处理扩展 schema

#### MySQL Add-on
**独特功能：**
- AUTO_INCREMENT 列
- ENUM 和 SET 类型
- 多种存储引擎（InnoDB、MyISAM）
- 预处理语句
- 查询提示

**解析考虑：**
- 标识符的反引号引用
- 单引号和双引号处理
- LIMIT ... OFFSET 语法
- SHOW 语句（非标准）

**Schema 内省：**
- 查询：`information_schema.tables`、`information_schema.columns`
- SHOW 命令：`SHOW TABLES`、`SHOW COLUMNS`、`SHOW DATABASES`
- 处理数据库与 schema 术语差异

---

## 4. 补全系统设计

### 4.1 补全管道

```
文档文本
     │
     ▼
┌─────────────────┐
│ 文本提取器      │ ← 提取光标周围的相关部分
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ 增量解析器      │ ← 仅在可能时解析更改的部分
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ 上下文分析器    │ ← 确定：语句类型、光标位置、
│                 │   期望的标记、可见的 schema
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ 候选项生成器    │ ← 从以下生成候选项：
│                 │   - 关键字
│                 │   - 函数
│                 │   - Schema 对象
│                 │   - 别名
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ 过滤引擎        │ ← 应用上下文规则：
│                 │   - 作用域可见性
│                 │   - 类型兼容性
│                 │   - 权限检查
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ 排序引擎        │ ← 排序依据：
│                 │   - 相关性
│                 │   - 使用频率
│                 │   - 上下文匹配
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ 截断器          │ ← 限制为合理数量（例如 50 项）
└────────┬────────┘
         │
         ▼
   LSP 响应
```

### 4.2 上下文感知补全

#### 4.2.1 上下文类型
1. **语句上下文**：SELECT、INSERT、UPDATE、DELETE、CREATE 等
2. **子句上下文**：WHERE、FROM、JOIN、GROUP BY 等
3. **位置上下文**：标记的开始、标记中间、关键字后
4. **作用域上下文**：光标位置可见的对象

#### 4.2.2 上下文感知规则

**示例场景：**

1. **"FROM" 或 "JOIN" 之后**：仅建议表/视图
2. **"WHERE" 之后**：建议列、函数、运算符
3. **在 SELECT 列表中**：建议列、聚合、表达式
4. **"." 之后**：建议前一个对象的成员
5. **在 CREATE TABLE 中**：建议数据类型、约束

#### 4.2.3 Schema 过滤

**可见性规则：**
- 仅显示用户有权访问的 schema/表
- 除非明确要求，否则隐藏系统 schema
- 尊重 search_path（PostgreSQL）或等价物
- 仅显示当前数据库的相关 schema

**实现：**
- 使用数据库元数据查询确定权限
- 缓存权限信息
- 在连接/重连时更新

**Schema 刷新策略：按需刷新**

Schema 元数据在需要时显式刷新，而不是按计划或实时刷新。

**刷新触发器：**
- 初始连接建立
- 通过 LSP 命令显式用户请求
- 检测到 schema 相关错误后（例如"表未找到"）
- 可配置的基于 TTL 的过期（默认：无过期）

**优势：**
- 最小的数据库负载
- 可预测的性能
- 无后台轮询开销
- 用户控制何时刷新

**实现：**
- 用于手动刷新的 LSP 自定义命令（例如"unified-sql-lsp.refreshSchema"）
- N 分钟后自动刷新的可选配置
- 带有时间戳的缓存元数据用于手动刷新检测
- 延迟刷新：首次引用时获取特定表的 schema

### 4.3 性能优化

#### 4.3.1 增量解析
- 仅解析包含光标的语句
- 缓存先前语句的解析树
- 光标在同一语句内移动时重用解析结果

#### 4.3.2 延迟求值
- 将昂贵的操作推迟到必要时
- 按优先级顺序生成候选项
- 找到足够的候选项时停止

#### 4.3.3 缓存策略
- 每个连接缓存 schema 信息
- 每个文档缓存解析树
- 文档更改时使缓存失效
- 基于 TTL 的缓存过期

#### 4.3.4 请求防抖
- 对补全请求进行防抖（例如 50ms 延迟）
- 新请求时取消待处理请求
- 优先处理最近的请求

---

## 5. 多连接架构

### 5.1 连接模型：多客户端单连接架构

**架构修正：**
```
旧模型：一个客户端 → 多个数据库连接
新模型：多个客户端 → 每个客户端一个数据库连接
```

**多客户端单连接模型：**
- 每个 LSP 客户端（如 Web 端、VS Code、Vim）维护一个数据库连接
- 服务器同时服务多个客户端
- 不同客户端之间的连接完全隔离
- 连接池用于管理每个连接的健康状态

**连接标识（安全设计）：**

```go
type ConnectionID struct {
    ClientID      string   // 客户端唯一标识（UUID）
    EngineType    string   // "postgresql", "mysql"
    EngineVersion string   // "14.5", "8.0.32"
    DatabaseName  string   // 数据库名称（不包含敏感信息）
    Fingerprint   string   // 连接配置的 SHA256 哈希
}
```

**安全措施：**
1. **连接字符串不存储**：仅在初始化时使用，建立连接后立即丢弃
2. **Fingerprint 机制**：使用 SHA256 哈希标识相同配置
   ```go
   Fingerprint = SHA256(EngineType + Host + Port + DatabaseName)
   ```
3. **凭证保护**：
   - 通过安全通道传递（如 LSP initialize 的加密参数）
   - 不记录日志
   - 内存中加密存储
4. **权限检查**：每个客户端只能访问自己的连接

**连接池管理：**
```go
type ConnectionManager struct {
    connections map[ConnectionID]*Connection
    pool        *DatabasePool
    mu          sync.RWMutex
}

func (m *ConnectionManager) GetConnection(connID ConnectionID) (*Connection, error) {
    // 1. 检查连接是否存在
    // 2. 健康检查
    // 3. 必要时重连
    // 4. 返回连接
}
```

**优势：**
- ✅ **安全性**：不暴露连接字符串，使用哈希标识
- ✅ **隔离性**：每个客户端独立的连接
- ✅ **可扩展**：支持大量并发客户端
- ✅ **容错性**：单个连接失败不影响其他客户端

### 5.2 连接生命周期

1. **初始化**
   - LSP 客户端通过配置/初始化提供引擎信息
   - 服务器为每个唯一数据库创建连接池
   - 测试连接有效性
   - 为引擎类型加载适当的 Add-on 插件

2. **运行**
   - 将每个文档与连接关联
   - 将补全请求路由到适当的连接
   - 使用连接池进行并发操作
   - 多个 LSP 客户端可以共享相同的底层数据库连接

3. **维护**
   - 定期对连接进行健康检查
   - 失败时重连
   - 超时后关闭空闲连接
   - 优雅处理客户端断开连接

### 5.4 部署模型：集中式服务器

**架构：**
- 单个 LSP 服务器实例同时处理多个客户端
- 服务器作为长期运行的守护程序/服务运行
- 客户端通过 TCP 或 stdio 连接
- 连接池允许高效的资源共享

**优势：**
- 高效的资源利用（共享 schema 缓存、Add-on 实例）
- 集中式配置和监控
- 更简单的部署和更新
- 更好的可观测性（指标/日志记录的单点）

**客户端-服务器通信：**
- TCP 网络客户端的 LSP
- 同时支持 stdio（本地开发）和 TCP（远程/协作）
- 每个客户端多文档的连接多路复用
- 不同客户端之间的会话隔离

### 5.3 并发模型

**每连接状态：**
- Schema 缓存
- 预处理语句
- 事务状态（如适用）

**共享状态：**
- Add-on 注册表
- 通用类型定义
- 配置

**并发策略：**
- 每个请求使用 goroutine（Go）或异步任务（Rust）
- 互斥锁保护共享状态
- 无锁的每连接状态
- 通过上下文取消请求

---

## 6. 技术选型

### 6.1 语言对比

#### Go
**优势：**
- 出色的并发支持（goroutines）
- 强大的标准库
- 易于编写和维护
- 良好的数据库驱动生态系统
- 快速编译
- 内置性能分析工具

**劣势：**
- 对于计算密集型任务比 Rust 慢
- 对内存布局的控制较少

**结论：**推荐用于本项目。并发模型和开发速度与需求非常契合。

#### Rust
**优势：**
- 最大性能
- 无 GC 的内存安全
- 出色的解析库（例如 nom）
- 零成本抽象

**劣势：**
- 学习曲线陡峭
- 开发时间更长
- 更复杂的异步故事
- 驱动生态系统不太成熟

**结论：**如果极致性能至关重要且团队具有 Rust 专业知识，则可行的替代方案。

### 6.2 推荐技术栈（Go + Wasm + Tree-sitter）

**核心技术决策：**
- **语言**：Go 1.24+（支持 `go:wasmexport`）
- **Wasm 运行时**：wazero（纯 Go，零依赖）
- **解析器生成**：Tree-sitter（增量解析）
- **插件架构**：Wasm Add-ons

**核心依赖：**
- **语言**：Go 1.24+
- **LSP 协议**：`github.com/sourcegraph/jsonrpc2`
- **Wasm 运行时**：`github.com/tetratelabs/wazero`
  - 纯 Go 实现，无需 CGo
  - 优秀的性能和安全性
- **Tree-sitter Go 绑定**：`github.com/smacker/go-tree-sitter`
  - Tree-sitter 的 Go 语言绑定
  - 支持增量解析
- **数据库驱动**：
  - PostgreSQL: `github.com/lib/pq`
  - MySQL: `github.com/go-sql-driver/mysql`
  - 未来：SQL Server (`github.com/microsoft/go-mssqldb`)、Oracle
- **解析器生成**：
  - Tree-sitter CLI: `tree-sitter-cli` (npm)
  - 官方语法文件：PostgreSQL `gram.y`、MySQL `sql_yacc.yy`
- **配置**：`github.com/spf13/viper`
- **日志记录**：`go.uber.org/zap`（高性能结构化日志）
- **指标**：`github.com/prometheus/client_golang`

**Wasm 相关依赖：**
- **Wasm 运行时**：`github.com/tetratelabs/wazero`
  - API：编译、实例化、函数调用
  - 主机函数：导出 Go 函数给 Wasm 调用
- **参考实现**：`github.com/knqyf263/go-plugin`
  - Wasm 插件系统设计参考

**潜在的库：**
- LSP: `github.com/sourcegraph/go-lsp` 或 `github.com/sourcegraph/jsonrpc2`
- 连接池：`database/sql` 与自定义池层
- HTTP 服务器（用于指标/健康）：`github.com/gin-gonic/gin` 或 stdlib

**项目结构（Wasm 架构）：**
```
unified-sql-lsp/
├── cmd/
│   └── server/
│       └── main.go              # 服务器入口点
├── internal/
│   ├── lsp/
│   │   ├── server.go            # LSP 服务器实现
│   │   ├── handler.go           # LSP 请求处理器
│   │   └── transport.go         # 传输层（stdio/TCP）
│   ├── addon/
│   │   ├── manager.go           # Add-on 生命周期管理
│   │   ├── loader.go            # Wasm Add-on 加载器
│   │   └── registry.go          # Add-on 注册表
│   ├── wasm/
│   │   ├── runtime.go           # Wasm 运行时管理
│   │   ├── host.go              # 主机函数导出
│   │   └── bridge.go            # Go-Wasm 桥接层
│   ├── parser/
│   │   ├── tree_sitter.go       # Tree-sitter 集成
│   │   ├── incremental.go       # 增量解析
│   │   └── cache.go             # 解析缓存
│   ├── completion/
│   │   ├── engine.go            # 补全引擎
│   │   ├── context.go           # 上下文分析
│   │   ├── filter.go            # 候选项过滤
│   │   └── rank.go              # 排序算法
│   ├── connection/
│   │   ├── manager.go           # 连接管理器（多客户端单连接）
│   │   ├── pool.go              # 连接池
│   │   ├── identity.go          # 安全连接标识
│   │   └── health.go            # 健康检查
│   ├── schema/
│   │   ├── cache.go             # Schema 缓存
│   │   ├── fetcher.go           # Schema 获取
│   │   └── filter.go            # Schema 过滤
│   └── config/
│       ├── server.go            # 服务器配置
│       └── client.go            # 客户端配置
├── pkg/
│   └── protocol/
│       └── types.go             # 共享 LSP 类型
├── addons/
│   ├── postgresql/
│   │   ├── manifest.yaml        # Add-on 元数据
│   │   ├── parser.go            # 解析器实现（Go → Wasm）
│   │   ├── completion.go        # 补全逻辑
│   │   ├── grammar.js           # Tree-sitter 语法
│   │   ├── postgresql.wasm      # 编译的 Wasm 模块
│   │   └── README.md
│   ├── mysql/
│   │   ├── manifest.yaml
│   │   ├── parser.go
│   │   ├── completion.go
│   │   ├── grammar.js
│   │   ├── mysql.wasm
│   │   └── README.md
│   └── tools/
│       ├── tree-sitter-generator.go  # Tree-sitter 生成工具
│       ├── wasm-compiler.go          # Wasm 编译脚本
│       └── bison-converter.go        # Bison → Tree-sitter 转换器
├── api/
│   └── addon.go                 # Add-on 接口定义
├── docs/
│   ├── 技术设计文档.md          # 本文档
│   ├── wasm-addon-guide.md      # Wasm Add-on 开发指南
│   └── parser-generation.md     # 解析器生成指南
├── scripts/
│   ├── build-wasm.sh            # Wasm 编译脚本
│   └── test-addon.sh            # Add-on 测试脚本
├── go.mod
├── go.sum
├── Makefile
└── README.md
```

**实现说明：**
- 使用 Go 1.24+ 的 `go:wasmexport` 导出函数
- wazero 运行时管理 Wasm 模块实例
- Tree-sitter 提供增量解析能力
- 主机函数机制：Wasm 调用 Go 函数获取 schema、日志等
- 使用 Go 上下文进行请求取消和超时
- 利用 sync.RWMutex 进行并发缓存访问
- 带有相关 ID 的结构化日志记录用于请求跟踪

---

## 7. 数据结构

### 7.1 文档状态
```go
type Document struct {
    URI              string
    Content          string
    Version          int
    ConnectionID     string
    ParseTree        *ParseTree
    LastParseVersion int
}

type ParseTree struct {
    Statements []Statement
    // Add-on 特定解析数据
}
```

### 7.2 补全上下文
```go
type CompletionContext struct {
    DocumentURI    string
    CursorPosition Position
    StatementType  StatementType
    ClauseType     ClauseType
    ExpectedTokens []TokenType
    VisibleScopes  []SchemaScope
    Aliases        map[string]string
}
```

### 7.3 补全项
```go
type CompletionItem struct {
    Label         string
    Kind          CompletionItemKind
    Detail        string
    Documentation string
    TextEdit      TextEdit
    SortText      string
    FilterText    string
    Score         float64
}
```

### 7.4 Schema 元数据
```go
type SchemaInfo struct {
    CatalogName   string
    SchemaName    string
    Tables        []TableInfo
    Functions     []FunctionInfo
    Types         []TypeInfo
    LastUpdated   time.Time
}

type TableInfo struct {
    Name       string
    Columns    []ColumnInfo
    IsView     bool
    IsSystem   bool
}

type ColumnInfo struct {
    Name     string
    DataType string
    Nullable bool
}
```

---

## 8. 错误处理和弹性

### 8.1 错误类别

1. **用户错误**
   - 无效的 SQL 语法
   - 标识符拼写错误
   - 操作：记录日志，返回空补全，不崩溃

2. **连接错误**
   - 数据库不可达
   - 身份验证失败
   - 操作：使用退避重试，通知用户，回退到缓存数据

3. **Add-on 错误**
   - Add-on 错误
   - 不支持的版本
   - 操作：隔离错误，记录堆栈跟踪，禁用 Add-on

4. **系统错误**
   - 内存不足
   - 资源耗尽
   - 操作：优雅降级，警报操作员

### 8.2 弹性策略

- **断路器**：临时禁用失败的 Add-on
- **回退**：在 schema 不可用时使用基本补全
- **超时**：所有数据库操作必须超时
- **资源限制**：最大连接数、每个连接的最大内存

---

## 9. 安全考虑

### 9.1 连接安全
- 支持数据库连接的 SSL/TLS
- 永不记录密码或敏感连接字符串
- 使用前验证连接字符串

### 9.2 SQL 注入防护
- 使用参数化查询进行 schema 内省
- 验证所有用户输入
- 永不在服务器上执行用户 SQL

### 9.3 Schema 访问控制
- 尊重数据库权限
- 仅查询用户有权访问的元数据
- 适当时遵守行级安全

### 9.4 信息泄露
- 不要在错误消息中暴露连接字符串
- 在发送到客户端之前清理堆栈跟踪
- 在日志中编辑敏感数据

---

## 10. 配置

### 11.1 客户端配置（LSP 初始化）

```go
type InitializeParams struct {
    ConnectionInfo ConnectionInfo
    EngineType     string
    EngineVersion  string
    SchemaRefreshInterval int
    CompletionPreferences CompletionPreferences
}

type ConnectionInfo struct {
    Engine         string
    Version        string
    ConnectionString string
    MaxConnections int
}

type CompletionPreferences struct {
    EnableKeywordCompletion bool
    EnableSchemaCompletion  bool
    MaxCompletionItems      int
    ShowSystemSchemas       bool
}
```

### 11.2 服务器配置

- Add-on 搜索路径
- 默认超时
- 缓存大小
- 日志记录配置
- 指标端点

---

## 11. 关键设计决策（已确认）

已最终确定以下架构决策：

1. **插件系统**：WebAssembly (Wasm) 插件系统
   - 使用 Go 1.24+ 的 `go:wasmexport` 指令
   - wazero 作为 Wasm 运行时（纯 Go，零依赖）
   - 启用第三方可扩展性
   - 独立的 Add-on 开发和分发
   - Wasm 沙箱提供完全隔离

2. **解析器生成策略**：官方语法文件 → Tree-sitter → Wasm
   - 从官方语法文件生成（PostgreSQL `gram.y`、MySQL `sql_yacc.yy`）
   - Tree-sitter 提供增量解析，专为编辑器优化
   - 每个 Add-on 编译为独立的 Wasm 模块
   - 核心要义：「得到语法解析器」——高效、方便、可扩展
   - 每种 SQL 方言的最大准确性
   - 不妥协解析正确性

3. **Schema 刷新**：手动触发的按需刷新
   - 最小的数据库负载
   - 用户通过 LSP 命令控制刷新
   - 可选的基于 TTL 的过期

4. **初始引擎**：MySQL 和 PostgreSQL（阶段 1-2）
   - PostgreSQL 优先（MVP）
   - MySQL 第二（证明多引擎能力）

5. **部署模型**：集中式服务器服务多个客户端
   - 单个 LSP 服务器实例同时服务多个客户端
   - 高效的资源共享（schema 缓存、Wasm 模块实例）
   - 更好的可观测性和管理
   - 支持 stdio 和 TCP 传输

### 技术选型确认

6. **编程语言**：Go 1.24+
   - Wasm 支持成熟（`go:wasmexport`）
   - wazero 运行时（纯 Go，无需 CGo）
   - Goroutines 适合多客户端并发
   - 开发效率高

7. **关键依赖**：
   - Wasm 运行时：wazero
   - 解析器：Tree-sitter + go-tree-sitter
   - LSP：sourcegraph/jsonrpc2
   - 日志：zap
   - 指标：Prometheus

### 待解决问题

1. **补全排序算法**
   - 简单的基于启发式评分？
   - 基于频率（跟踪用户选择）？
   - 未来：基于 ML 的排序？

2. **大型 Schema 性能**
   - 对于具有 10,000+ 表的数据库的策略？
   - 表元数据的延迟加载？
   - Schema 索引？

---

## 12. 成功标准

**性能指标：**
- 95th 百分位补全延迟 < 100ms
- 99th 百分位补全延迟 < 200ms
- Schema 缓存命中率 > 95%
- 支持 50+ 并发数据库连接
- 支持 10+ 并发 LSP 客户端

**开发指标：**
- 新引擎 Add-on 开发时间 < 1 周
- 插件加载时间 < 500ms
- 服务器启动时间 < 2 秒

**质量指标：**
- 集中式服务器 99.9% 正常运行时间
- 零数据丢失（无崩溃导致的数据损坏）
- 错误时的优雅降级
- 全面的测试覆盖率（> 80%）

**生态系统指标：**
- 12 个月内支持前 10 个 SQL 数据库
- 第三方 Add-on 开发工具包和文档
- 插件市场或注册表（未来）

## 13. 总结和下一步

### 确认的架构决策

本技术设计基于以下关键架构决策：

1. **动态插件系统**：Add-on 是动态加载的插件，支持第三方可扩展性和独立开发
2. **引擎特定解析器**：每个 Add-on 实现针对该 SQL 方言优化的自己的解析器
3. **按需 Schema 刷新**：Schema 元数据在需要时显式刷新，而不是按计划
4. **PostgreSQL 和 MySQL 优先**：初始实现专注于这两个引擎
5. **集中式服务器部署**：单个服务器实例并发服务多个 LSP 客户端
6. **Go 实现**：使用 Go 实现性能、并发和开发速度的最佳平衡

### 架构亮点

**核心组件：**
- LSP 传输层：处理协议通信（stdio 和 TCP）
- 请求分发器：路由请求、取消和防抖
- 连接管理器：管理数据库连接池和健康
- Add-on 管理器：发现、加载和管理引擎插件
- 补全引擎：快速、上下文感知的补全，增量解析
- Schema 缓存管理器：积极缓存和按需刷新

**关键设计原则：**
1. **模块化**：插件架构以实现最大可扩展性
2. **性能**：通过增量解析和缓存实现 < 100ms p95 延迟
3. **并发**：支持 50+ 数据库连接和 10+ LSP 客户端
4. **上下文感知**：基于 SQL 语法和 schema 上下文的智能补全
5. **弹性**：错误隔离和优雅降级
6. **可观测性**：全面的日志记录、指标和跟踪

### 实施阶段

**阶段 1 (MVP)**：PostgreSQL 支持和基本补全
**阶段 2**：MySQL 支持和多连接
**阶段 3**：高级上下文感知补全
**阶段 4**：生产就绪和可观测性
**阶段 5**：扩展到更多引擎和生态系统

### 文档位置

本文档应放置在：
```
unified-sql-lsp/docs/技术设计文档.md
```

### 相关文档需求

未来文档应包括：
1. **Add-on 开发指南**：如何创建新引擎插件
2. **API 参考**：Add-on 接口规范
3. **部署指南**：服务器设置和配置
4. **用户指南**：客户端配置和使用
5. **架构图**：系统的可视化表示
